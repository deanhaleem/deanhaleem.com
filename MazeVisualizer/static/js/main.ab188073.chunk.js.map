{"version":3,"sources":["MazeVisualizer/Node.jsx","Algorithms/randomizedPrims.js","Algorithms/recursiveBacktracker.js","MazeVisualizer/MazeVisualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["Node","this","props","col","row","id","className","Component","addAdjacentEdgesToEL","edgeList","maze","node","includes","e","start","end","nodesBetween","push","edge","Edge","length","getUnivistedNeighbors","unvisitedNeighbors","isVisited","addEdgeToMinSpanningTree","neighbor","minSpanningTree","MazeGenerationVisualizer","state","grid","getInitialGrid","setState","document","getElementById","classList","toggle","minSpanning","startNode","numNodes","numNodesVisited","Math","floor","random","index","indexOf","splice","randomizedPrims","ROWS","animateMinSpanningAlgorithm","COLS","stack","pop","recursiveBacktrack","nodesInMinSpanningTree","i","setTimeout","destroyWall","ButtonToolbar","Button","onClick","visualizeRandomizedPrims","variant","block","visualizeRecursiveBacktrack","reset","toggleGridLines","map","rowIdx","key","nodeIdx","currentRow","createNode","App","Boolean","window","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.ab188073.chunk.js","sourcesContent":["import React, { Component } from \"react\";\r\n\r\nimport \"./Node.css\";\r\n\r\nexport default class Node extends Component {\r\n  render() {\r\n    const { col, row } = this.props;\r\n\r\n    return <div id={`node-${row}-${col}`} className={`node`}></div>;\r\n  }\r\n}\r\n","/*\r\n    1) Start with empty edge list set (EL)\r\n    2) Choose random starting node (not random in this case)\r\n    3) Add all adjacent edges of the current node to EL if they\r\n       have no already been added\r\n    4) Choose random edge from EL and remove it from EL\r\n    5) If the edge if not between two visited nodes, it becomes\r\n       a spanning tree edge, and the process moves to the\r\n       neighboring node.\r\n    6) Repeat steps 3-5 until spanning tree or empty EL\r\n*/\r\nexport function randomizedPrims(maze, startNode, numNodes) {\r\n  var numNodesVisited = 0;\r\n  var minSpanningTree = [];\r\n  var edgeList = [];\r\n\r\n  addAdjacentEdgesToEL(edgeList, maze, startNode);\r\n  startNode.isVisited = true;\r\n\r\n  while (numNodesVisited < numNodes && edgeList.length > 0) {\r\n    // get random edge\r\n    var edge = edgeList[Math.floor(Math.random() * edgeList.length)];\r\n\r\n    /*\r\n        The start of an edge will always be\r\n        visited. Otherwise, there's no way\r\n        it could be in the EL.\r\n    */\r\n    if (!edge.end.isVisited) {\r\n      edge.end.isVisited = true;\r\n      numNodesVisited++;\r\n      minSpanningTree.push(edge);\r\n\r\n      addAdjacentEdgesToEL(edgeList, maze, edge.end);\r\n    }\r\n\r\n    // remove edge\r\n    var index = edgeList.indexOf(edge);\r\n    if (index > -1) {\r\n      edgeList.splice(index, 1);\r\n    }\r\n  }\r\n\r\n  return minSpanningTree;\r\n}\r\n\r\n/*\r\n    This won't add the edge if it is already in\r\n    edgeList.\r\n*/\r\nfunction addAdjacentEdgesToEL(edgeList, maze, node) {\r\n  const { col, row } = node;\r\n\r\n  if (\r\n    row > 3 &&\r\n    !edgeList.includes(e => e.start == node && e.end.col == maze[row - 3][col])\r\n  ) {\r\n    // edge from node to neighbor above\r\n    var nodesBetween = [];\r\n    nodesBetween.push(maze[row - 1][col]);\r\n    nodesBetween.push(maze[row - 2][col]);\r\n    var edge = new Edge(node, maze[row - 3][col], nodesBetween);\r\n    edgeList.push(edge);\r\n  }\r\n  if (\r\n    row < maze.length - 3 &&\r\n    !edgeList.includes(\r\n      e => e.start.col == node && e.end.col == maze[row + 3][col]\r\n    )\r\n  ) {\r\n    // edge from node to neighbor below\r\n    var nodesBetween = [];\r\n    nodesBetween.push(maze[row + 1][col]);\r\n    nodesBetween.push(maze[row + 2][col]);\r\n    var edge = new Edge(node, maze[row + 3][col], nodesBetween);\r\n    edgeList.push(edge);\r\n  }\r\n  if (\r\n    col > 3 &&\r\n    !edgeList.includes(\r\n      e => e.start.col == node && e.end.col == maze[row][col - 3]\r\n    )\r\n  ) {\r\n    // edge from node to neighbor to the left\r\n    var nodesBetween = [];\r\n    nodesBetween.push(maze[row][col - 1]);\r\n    nodesBetween.push(maze[row][col - 2]);\r\n    var edge = new Edge(node, maze[row][col - 3], nodesBetween);\r\n    edgeList.push(edge);\r\n  }\r\n  if (\r\n    col < maze.length - 3 &&\r\n    !edgeList.includes(\r\n      e => e.start.col == node && e.end.col == maze[row][col + 3]\r\n    )\r\n  ) {\r\n    // edge from node to neighbor to the right\r\n    var nodesBetween = [];\r\n    nodesBetween.push(maze[row][col + 1]);\r\n    nodesBetween.push(maze[row][col + 2]);\r\n    var edge = new Edge(node, maze[row][col + 3], nodesBetween);\r\n    edgeList.push(edge);\r\n  }\r\n}\r\n\r\n/*\r\n    Keeping track of the nodes between makes it \r\n    slightly easier to animate the spanning tree\r\n*/\r\nclass Edge {\r\n  constructor(start, end, nodesBetween) {\r\n    this.start = start;\r\n    this.end = end;\r\n    this.nodesBetween = nodesBetween;\r\n  }\r\n}\r\n","/*\r\n    1) Choose a starting point on maze\r\n    2) Choose one of its neighboring nodes\r\n       randomly\r\n    3) If the neighbor has no been visited,\r\n       the edge between the current node and\r\n       the neighbor is a spanning tree edge. \r\n       Process moves to neighbor.\r\n    4) If all adjacent nodes have been visited,\r\n       back up to last node that has unvisited\r\n       neighbors.\r\n    5) Repeat process 2-4 until back at starting\r\n       node.\r\n*/\r\nexport function recursiveBacktrack(maze, startNode, numNodes) {\r\n  var numNodesVisited = 0;\r\n  var minSpanningTree = [];\r\n\r\n  // I use a stack instread of recursion as it was simple enough here\r\n  var stack = [];\r\n\r\n  startNode.isVisited = true;\r\n  stack.push(startNode);\r\n\r\n  /*\r\n    I include the numNodesVisited check just in case\r\n    something goes wrong with the stack\r\n  */\r\n  while (numNodesVisited < numNodes && stack.length > 0) {\r\n    var node = stack.pop();\r\n\r\n    var unvisitedNeighbors = getUnivistedNeighbors(node, maze);\r\n\r\n    // skip the loop if we don't have any unvisited neighbors\r\n    if (unvisitedNeighbors.length > 0) {\r\n      stack.push(node);\r\n    } else {\r\n      continue;\r\n    }\r\n\r\n    var neighbor =\r\n      unvisitedNeighbors[Math.floor(Math.random() * unvisitedNeighbors.length)];\r\n    neighbor.isVisited = true;\r\n    numNodesVisited++;\r\n    addEdgeToMinSpanningTree(node, neighbor, maze, minSpanningTree);\r\n\r\n    stack.push(neighbor);\r\n  }\r\n\r\n  return minSpanningTree;\r\n}\r\n\r\nfunction getUnivistedNeighbors(node, maze) {\r\n  const { col, row } = node;\r\n\r\n  var unvisitedNeighbors = [];\r\n  if (row > 3 && !maze[row - 3][col].isVisited) {\r\n    unvisitedNeighbors.push(maze[row - 3][col]);\r\n  }\r\n\r\n  if (row < maze.length - 3 && !maze[row + 3][col].isVisited) {\r\n    unvisitedNeighbors.push(maze[row + 3][col]);\r\n  }\r\n\r\n  if (col > 3 && !maze[row][col - 3].isVisited) {\r\n    unvisitedNeighbors.push(maze[row][col - 3]);\r\n  }\r\n\r\n  if (col < maze.length - 3 && !maze[row][col + 3].isVisited) {\r\n    unvisitedNeighbors.push(maze[row][col + 3]);\r\n  }\r\n\r\n  return unvisitedNeighbors;\r\n}\r\n\r\nfunction addEdgeToMinSpanningTree(node, neighbor, maze, minSpanningTree) {\r\n  const { col, row } = node;\r\n\r\n  if (neighbor.col > col) {\r\n    // edge from node to neighbor below\r\n    var nodesBetween = [];\r\n    nodesBetween.push(maze[row][col + 1]);\r\n    nodesBetween.push(maze[row][col + 2]);\r\n    var edge = new Edge(node, neighbor, nodesBetween);\r\n    minSpanningTree.push(edge);\r\n  } else if (neighbor.col < col) {\r\n    // edge from node to neighbor above\r\n    var nodesBetween = [];\r\n    nodesBetween.push(maze[row][col - 1]);\r\n    nodesBetween.push(maze[row][col - 2]);\r\n    var edge = new Edge(node, neighbor, nodesBetween);\r\n    minSpanningTree.push(edge);\r\n  } else if (neighbor.row > row) {\r\n    // edge from node to neighbor to the right\r\n    var nodesBetween = [];\r\n    nodesBetween.push(maze[row + 1][col]);\r\n    nodesBetween.push(maze[row + 2][col]);\r\n    var edge = new Edge(node, neighbor, nodesBetween);\r\n    minSpanningTree.push(edge);\r\n  } else {\r\n    // edge from node to neighbor to the left\r\n    var nodesBetween = [];\r\n    nodesBetween.push(maze[row - 1][col]);\r\n    nodesBetween.push(maze[row - 2][col]);\r\n    var edge = new Edge(node, neighbor, nodesBetween);\r\n    minSpanningTree.push(edge);\r\n  }\r\n}\r\n\r\nclass Edge {\r\n  constructor(start, end, nodesBetween) {\r\n    this.start = start;\r\n    this.end = end;\r\n    this.nodesBetween = nodesBetween;\r\n  }\r\n}\r\n","import React, { Component } from \"react\";\r\nimport Button from \"react-bootstrap/Button\";\r\nimport ButtonToolbar from \"react-bootstrap/ButtonToolbar\";\r\nimport Node from \"./Node\";\r\nimport { randomizedPrims } from \"../Algorithms/randomizedPrims\";\r\nimport { recursiveBacktrack } from \"../Algorithms/recursiveBacktracker\";\r\n\r\nimport \"./MazeVisualizer.css\";\r\n\r\nconst ROWS = 21;\r\nconst COLS = 21;\r\n\r\nexport default class MazeGenerationVisualizer extends Component {\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      grid: []\r\n    };\r\n  }\r\n\r\n  componentDidMount() {\r\n    const maze = getInitialGrid();\r\n    this.setState({ grid: maze });\r\n  }\r\n\r\n  reset() {\r\n    for (let row = 0; row < ROWS; row++) {\r\n      for (let col = 0; col < COLS; col++) {\r\n        document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n      }\r\n    }\r\n\r\n    const maze = getInitialGrid();\r\n    this.setState({ grid: maze });\r\n  }\r\n\r\n  toggleGridLines() {\r\n    for (let row = 0; row < ROWS; row++) {\r\n      for (let col = 0; col < COLS; col++) {\r\n        document.getElementById(`node-${row}-${col}`).classList.toggle(\"toggle-grid\");\r\n      }\r\n    }\r\n  }\r\n\r\n  visualizeRandomizedPrims() {\r\n    const { grid: maze } = this.state;\r\n    const startNode = maze[1][1];\r\n\r\n    const minSpanning = randomizedPrims(\r\n      maze,\r\n      startNode,\r\n      (ROWS / 3) * (COLS / 3)\r\n    );\r\n    var nodesInMinSpanningTree = [];\r\n    this.animateMinSpanningAlgorithm(minSpanning, nodesInMinSpanningTree);\r\n\r\n    document.getElementById(`node-${0}-${1}`).className = \"node node-visited\";\r\n    document.getElementById(`node-${ROWS - 1}-${COLS - 2}`).className =\r\n      \"node node-visited\";\r\n  }\r\n\r\n  visualizeRecursiveBacktrack() {\r\n    const { grid: maze } = this.state;\r\n    const startNode = maze[1][1];\r\n\r\n    const minSpanning = recursiveBacktrack(\r\n      maze,\r\n      startNode,\r\n      (ROWS / 3) * (COLS / 3)\r\n    );\r\n    var nodesInMinSpanningTree = [];\r\n    this.animateMinSpanningAlgorithm(minSpanning, nodesInMinSpanningTree);\r\n\r\n    document.getElementById(`node-${0}-${1}`).className = \"node node-visited\";\r\n    document.getElementById(`node-${ROWS - 1}-${COLS - 2}`).className =\r\n      \"node node-visited\";\r\n  }\r\n\r\n  animateMinSpanningAlgorithm(minSpanning, nodesInMinSpanningTree) {\r\n    for (let i = 0; i < minSpanning.length; i++) {\r\n      setTimeout(() => {\r\n        const edge = minSpanning[i];\r\n        nodesInMinSpanningTree.push(edge.start);\r\n        nodesInMinSpanningTree.push(edge.nodesBetween[0]);\r\n        nodesInMinSpanningTree.push(edge.nodesBetween[1]);\r\n        nodesInMinSpanningTree.push(edge.end);\r\n        this.destroyWall(edge);\r\n      }, 50 * i);\r\n    }\r\n  }\r\n\r\n  destroyWall(edge) {\r\n    setTimeout(() => {\r\n      const node = edge.start;\r\n      document.getElementById(`node-${node.row}-${node.col}`).className =\r\n        \"node node-visited\";\r\n    }, 50 * 0);\r\n\r\n    setTimeout(() => {\r\n      const node = edge.end;\r\n      document.getElementById(`node-${node.row}-${node.col}`).className =\r\n        \"node node-visited\";\r\n    }, 50 * 0);\r\n\r\n    setTimeout(() => {\r\n      const node = edge.nodesBetween[0];\r\n      document.getElementById(`node-${node.row}-${node.col}`).className =\r\n        \"node node-visited\";\r\n    }, 50 * 0);\r\n\r\n    setTimeout(() => {\r\n      const node = edge.nodesBetween[1];\r\n      document.getElementById(`node-${node.row}-${node.col}`).className =\r\n        \"node node-visited\";\r\n    }, 50 * 1);\r\n  }\r\n\r\n  render() {\r\n    const { grid: maze } = this.state;\r\n\r\n    return (\r\n      <>\r\n        <ButtonToolbar>\r\n          <Button\r\n            onClick={() => this.visualizeRandomizedPrims()}\r\n            variant=\"primary\"\r\n            block\r\n          >\r\n            Visualize Randomized Prim's\r\n          </Button>\r\n          <Button\r\n            onClick={() => this.visualizeRecursiveBacktrack()}\r\n            variant=\"primary\"\r\n            block\r\n          >\r\n            Visualize Recursive Backtrack\r\n          </Button>\r\n          <Button\r\n            onClick={() => this.reset()}\r\n            variant=\"secondary\"\r\n            block\r\n          >\r\n            Reset\r\n          </Button>\r\n          <Button\r\n            onClick={() => this.toggleGridLines()}\r\n            variant=\"secondary\"\r\n            block\r\n          >\r\n            Toggle Grid Lines\r\n          </Button>\r\n        </ButtonToolbar>\r\n\r\n        <div className=\"grid\">\r\n          {maze.map((row, rowIdx) => {\r\n            return (\r\n              <div key={rowIdx} className=\"grid-row\">\r\n                {row.map((node, nodeIdx) => {\r\n                  const { row, col } = node;\r\n                  return <Node key={nodeIdx} col={col} row={row}></Node>;\r\n                })}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nconst getInitialGrid = () => {\r\n  const grid = [];\r\n  for (let row = 0; row < ROWS; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < COLS; col++) {\r\n      var node = createNode(col, row);\r\n      currentRow.push(node);\r\n    }\r\n    grid.push(currentRow);\r\n  }\r\n\r\n  return grid;\r\n};\r\n\r\nconst createNode = (col, row) => {\r\n  return {\r\n    col,\r\n    row,\r\n    isVisited: false\r\n  };\r\n};\r\n","import React from 'react';\nimport './App.css';\nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport MazeGenerationVisualizer from './MazeVisualizer/MazeVisualizer';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <MazeGenerationVisualizer></MazeGenerationVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}